<!DOCTYPE html>
<html lang="en">

<head>
    <title>three-ag drag & drop</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="shortcut icon" href="files/favicon.ico" />
    <link type="text/css" rel="stylesheet" href="files/main.css">
</head>

<body>
    <div id="info">
        <a href="https://github.com/agargaro/three-interaction" target="_blank" rel="noopener">ag-three</a> - bubble<br>
        Click to drag the bubble.
    </div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "../src/index": "./bundle.js",
                "three": "https://unpkg.com/three/build/three.module.min.js",
                "three/examples/": "https://unpkg.com/three/examples/"
            }
        }
    </script>

    <script type="module">

import { WebGLRenderTarget, CircleGeometry, Mesh, Scene as SceneBase, MeshLambertMaterial, DirectionalLight, SphereGeometry } from 'three';
        import { FontLoader } from 'three/examples/jsm/loaders/FontLoader';
        import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry';
        import { Main, PerspectiveCamera, BubbleMaterial, InstancedMeshSingle, InstancedMesh } from "../src/index";

        class Text extends Mesh {
            constructor(text) {
                super(undefined, new MeshLambertMaterial({ color: 0xffff55 }));
                const loader = new FontLoader();
                
                loader.load("fonts/helvetiker_regular.typeface.json", (font) => {
                    this.geometry = new TextGeometry(text, { font, size: 2, height: 1 });
                    this.geometry.computeBoundingBox();
                    const offsetX = -0.5 * (this.geometry.boundingBox.max.x - this.geometry.boundingBox.min.x);
                    const offsetY = -0.5 * (this.geometry.boundingBox.max.y - this.geometry.boundingBox.min.y);
                    this.position.set(offsetX, offsetY, -3);
                });
            }
        }

        class Bubble extends Mesh {
            constructor() {
                super(new CircleGeometry(2, 128, 128), new BubbleMaterial());
                this.setManualDetectionMode();
                this.draggable = true;

                this.bindEvent("rendererresize", async (args) => {
                    this.material.setResolution(args.width * window.devicePixelRatio, args.height * window.devicePixelRatio);
                });
                this.bindEvent("animate", (args) => this.material.setTime(args.total));
                this.bindProperty("visible", () => !this.parent?.isTextureRendering);
            }
        }

        class Particle extends InstancedMeshSingle {
            constructor(parent, index, color) {
                super(parent, index, color);
                const angleX = Math.random() * Math.PI * 2;
                const angleY = Math.random() * Math.PI * 2;
                const multiplier = Math.random() * 2 - 1;
                this.scale.setScalar(2 * Math.random());
                this.setColor(Math.random() * 0xffffff);

                this.bindEvent("animate", (e) => {
                    this.position.setFromSphericalCoords(10, angleX + Math.sin(e.total / 5 * multiplier), angleY + Math.sin(e.total / 5 * multiplier));
                    this.updateMatrix();
                });
            }
        }

        class Scene extends SceneBase {

            constructor(renderer) {
                super();
                this.renderTarget = new WebGLRenderTarget(1, 1, { samples: 4 });
                this.isTextureRendering = false;

                this.add(
                    this.camera = new PerspectiveCamera(70).translateZ(10),
                    new DirectionalLight(0xffffff, 0.7).translateZ(10),
                    this.bubble = new Bubble(),
                    new Text("three-keko"),
                    new InstancedMesh(new SphereGeometry(0.03, 10, 10), new MeshLambertMaterial(), 5000, Particle)
                );

                this.bubble.material.setTexture(this.renderTarget.texture); //TODO sceneadd event?

                this.bindEvent("rendererresize", async (args) => {
                    this.renderTarget.setSize(args.width, args.height);
                });

                this.bindEvent("afteranimate", (args) => {
                    this.isTextureRendering = true;
                    this.detectChanges(true);
                    renderer.setRenderTarget(this.renderTarget);
                    renderer.render(this, this.camera);
                    renderer.setRenderTarget(null);
                    this.isTextureRendering = false;
                    this.detectChanges(true);
                });
            }
        }

        const main = new Main({}, { antialias: true });
        main.addScene(new Scene(main.renderer));

    </script>
</body>

</html>