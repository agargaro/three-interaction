<!DOCTYPE html>
<html lang="en">

<head>
    <title>three-ag binding</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="shortcut icon" href="files/favicon.ico" />
    <link type="text/css" rel="stylesheet" href="files/main.css">
</head>

<body>
    <div id="info">
        <a href="https://github.com/agargaro/three-interaction" target="_blank" rel="noopener">ag-three</a> -
        binding<br>
        Bouncing spheres that become red when collide.
    </div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.min.js",
                "three/examples/": "https://unpkg.com/three/examples/",
                "lil-gui": "https://unpkg.com/lil-gui@0.18.1/dist/lil-gui.esm.min"
            }
        }
    </script>

    <script type="module">

        import { BoxGeometry, CircleGeometry, Color, DirectionalLight, DoubleSide, Line3, Mesh, MeshBasicMaterial, MeshLambertMaterial, Plane, Scene, SphereGeometry, Vector3 } from "three";
        import { PerspectiveCamera, Main, LinkedLine } from "../src/index";
        import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
        import GUI from "lil-gui";

        const maxSpheres = 500;
        let showImpact = true;
        let timeSpeed = 5;
        let spheresCount = 30;
        const colorVisibility = [true, true, true, true];
        const sphereRadius = 0.4;
        const impactGeometry = new CircleGeometry(sphereRadius, 16);
        const sphereGeometry = new SphereGeometry(sphereRadius);
        const sphereMaterial = [
            new MeshLambertMaterial({ color: 0x00ff00 }), new MeshLambertMaterial({ color: 0xffffff }),
            new MeshLambertMaterial({ color: 0x0000ff }), new MeshLambertMaterial({ color: 0xff0000 })
        ];
        const sphere = [];
        const lineDir = new Line3();
        const newPos = new Vector3();
        const intersection = new Vector3();

        class Sphere extends Mesh {

            constructor(index) {
                super(sphereGeometry);
                this._dir = new Vector3().randomDirection();
                const materialIndex = index % 3;

                this.bindProperty("material", () => sphereMaterial[this.isColliding ? 3 : materialIndex]);
                this.bindProperty("visible", () => spheresCount > index && colorVisibility[this.isColliding ? 3 : materialIndex]);

                this.bindEvent("animate", (e) => {
                    if (spheresCount <= index) return;
                    let bounced;
                    this.isColliding = false;
                    this._dir.setLength(e.delta * timeSpeed || 1e-5);
                    newPos.addVectors(this.position, this._dir);

                    do {
                        bounced = false;
                        lineDir.set(this.position, newPos);

                        for (const face of boxFaces) {
                            if (face.intersectsLine(lineDir)) {
                                bounced = true;
                                this.calculateBounce(face);
                                this.parent.add(new Impact(intersection, face.normal, sphereMaterial[materialIndex].color));
                                break;
                            }
                        }
                    } while (bounced);

                    this.position.copy(newPos);
                });
            }

            calculateBounce(plane) {
                plane.intersectLine(lineDir, intersection);
                const newLength = newPos.distanceTo(intersection);
                this._dir.setLength(Math.max(newLength, 1e-5)).reflect(plane.normal);
                newPos.addVectors(intersection, this._dir);
            }

            checkCollisionWithSphere(sphere) {
                if (this.position.distanceTo(sphere.position) < sphereRadius * 2) {
                    this.isColliding = sphere.isColliding = true;
                }
            }
        }

        class Impact extends Mesh {

            constructor(position, faceNormal, color) {
                super(impactGeometry, new MeshBasicMaterial({ color, transparent: true, opacity: 0.7, side: DoubleSide }));

                this.position.copy(position).sub(faceNormal.clone().setLength(sphereRadius));
                this.lookAt(this.position.clone().add(faceNormal));
                this.bindProperty("visible", () => showImpact);

                this.bindEvent("animate", (e) => {
                    this.material.opacity -= e.delta * timeSpeed / 4;
                    this.scale.setScalar(this.material.opacity)
                    if (this.material.opacity <= 0) {
                        this.material.dispose();
                        this.removeFromParent();
                    }
                });
            }
        }

        const scene = new Scene();
        scene.interceptByRaycaster = false; //todo migliora
        scene.add(
            scene.camera = new PerspectiveCamera(70).translateZ(12),
            scene.light = new DirectionalLight(0xffffff),
            scene.box = new Mesh(new BoxGeometry(9, 9, 9, 5, 5, 5), new MeshBasicMaterial({ wireframe: true, transparent: true, opacity: 0.1 }))
        );

        scene.box.geometry.computeBoundingBox();
        const bbox = scene.box.geometry.boundingBox;
        const boxFaces = [
            new Plane(new Vector3(-1)).translate(new Vector3(bbox.max.x - sphereRadius)),
            new Plane(new Vector3(1)).translate(new Vector3(bbox.min.x + sphereRadius)),
            new Plane(new Vector3(0, -1)).translate(new Vector3(0, bbox.max.y - sphereRadius)),
            new Plane(new Vector3(0, 1)).translate(new Vector3(0, bbox.min.y + sphereRadius)),
            new Plane(new Vector3(0, 0, -1)).translate(new Vector3(0, 0, bbox.max.z - sphereRadius)),
            new Plane(new Vector3(0, 0, 1)).translate(new Vector3(0, 0, bbox.min.z + sphereRadius))
        ];

        scene.light.matrixAutoUpdate = false;
        scene.light.matrix = scene.camera.matrix;

        for (let i = 0; i < maxSpheres; i++) {
            scene.add(sphere[i] = new Sphere(i));
        }

        scene.bindEvent("animate", function (e) {
            for (let i = 0; i < spheresCount - 1; i++) {
                for (let j = i + 1; j < spheresCount; j++) {
                    sphere[i].checkCollisionWithSphere(sphere[j]);
                }
            }
        });

        window.main = new Main([scene], true, { antialias: true });

        const controls = new OrbitControls(scene.camera, window.main.renderer.domElement);
        scene.bindCallback("controls", () => controls.autoRotate && controls.update());

        const layers = {
            "toggle green": colorVisibility[0],
            "toggle white": colorVisibility[1],
            "toggle blue": colorVisibility[2],
            "toggle red": colorVisibility[3],
            "show impact": showImpact,
            "speed": timeSpeed,
            "spheres count": spheresCount,
            "auto rotate": controls.autoRotate
        };

        const gui = new GUI();
        gui.add(layers, "toggle green").onChange((value) => colorVisibility[0] = value);
        gui.add(layers, "toggle white").onChange((value) => colorVisibility[1] = value);
        gui.add(layers, "toggle blue").onChange((value) => colorVisibility[2] = value);
        gui.add(layers, "toggle red").onChange((value) => colorVisibility[3] = value);
        gui.add(layers, "show impact").onChange((value) => showImpact = value);
        gui.add(layers, "speed", 1, 20, 1).onChange((value) => timeSpeed = value);
        gui.add(layers, "spheres count", 3, maxSpheres, 3).onChange((value) => spheresCount = value);
        gui.add(layers, "auto rotate").onChange((value) => controls.autoRotate = value);

    </script>
</body>

</html>